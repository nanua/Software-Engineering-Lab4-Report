% !Mode:: "TeX:UTF-8" 
\renewcommand{\textfraction}{0.05} 
\BiChapter{实验要求}{}
本次实验的要求为对Lab1所完成的代码进行代码的评审以及性能分析，并从性能角度对代码进行优化。其中，代码的评审包括静态分析以及动态分析两个方面，并且在实验中逐一使用Checkstyle，FindBugs，PMD，VisualVM四个工具对代码进行评审以及性能分析。

在本次实验中，采用Lab1的分组方式（即两人一组），并随机分配另一组作为本组的评审和分析对象，并要求实验期间不能与原作者进行沟通。
% -------------------------------章节分割线-------------------------------
\BiChapter{在IntelliJ中配置代码审查与分析工具}{}
在本章中，将通过文字以及图片来对在IntelliJ中配置Checkstyle，PMD，FindBugs，VisualVM四种工具的步骤逐一进行叙述。
\BiSection{Checkstyle}{}
在本节中，将描述在IntelliJ中安装以及配置Checkstyle的方法。

首先，在IntelliJ中打开项目，然后在顶端的File选项栏中选择Setting选项，并在弹出的窗口中的左侧边栏中选择Plugins选项卡。
然后，在输入栏中输入“Checkstyle”，如图\ref{fig:cs-1}所示。

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/cs-1}
\caption{Plugins选项卡}
\label{fig:cs-1}
\end{figure}

然后，点击其中的Search in repositories，在弹出的窗口中点击Install，如图\ref{fig:cs-2}所示。等待安装完成后，由此即完成了IntelliJ上Checkstyle的安装。

\begin{figure}
\centering
\includegraphics[width=10cm]{/../figures/cs-2}
\caption{Browse Repositories界面}
\label{fig:cs-2}
\end{figure}

在安装完成后，我们在Setting中左边栏选择Other Settings，Checkstyle。在出现的页面中的Configuration File选项中选择默认的Sun Checks作为风格检查的标准，如图\ref{fig:cs-3}所示，然后点击OK进行确定。由此，即完成了Checkstyle的配置。
\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/cs-3}
\caption{设置检查标准}
\label{fig:cs-3}
\end{figure}

\BiSection{PMD}{}
在本节中，将描述在IntelliJ中安装以及配置PMD的方法。

与Checkstyle的安装方式基本一致，首先我们在Setting中的Plugins选项卡内输入“PMD”，点击Search in repositories，在出现的窗口中选择PMDPlugin，点击Install进行安装，等待安装完成。安装完后如图\ref{fig:pmd-1}所示。

\begin{figure}
\centering
\includegraphics[width=10cm]{/../figures/pmd-1}
\caption{安装PMD}
\label{fig:pmd-1}
\end{figure}

由于本次实验中我们将直接使用PMD默认的配置，因此不需要进行额外的配置。

\BiSection{FindBugs}{}
在本节中，将描述在IntelliJ中安装FindBugs的方法。

与Checkstyle的安装方式基本一致，首先我们在Setting中的Plugins选项卡内输入“FindBugs”，点击Search in repositories，在出现的窗口中选择FindBugs-IDEA，点击Install进行安装，等待安装完成。安装完后如图\ref{fig:fb-1}所示。

\begin{figure}
\centering
\includegraphics[width=10cm]{/../figures/fb-1}
\caption{安装FindBugs}
\label{fig:fb-1}
\end{figure}

\BiSection{VisualVM}{}
在本节中，将描述在IntelliJ中安装VisualVM的方法。

由于JDK中自带VisualVM软件，因此不需要额外安装VisualVM。不过，为了能够在IntelliJ中方便地使用VisualVM，我们选择安装VisualVM Launcher插件。该插件的安装过程与Checkstyle的安装方式基本一致，首先我们在Setting中的Plugins选项卡内输入“VisualVM”，点击Search in repositories，在出现的窗口中选择VisualVM Launcher，点击Install进行安装，等待安装完成。安装完后如图\ref{fig:vv-1}所示。

\begin{figure}
\centering
\includegraphics[width=10cm]{/../figures/vv-1}
\caption{VisualVM Launcher安装}
\label{fig:vv-1}
\end{figure}

% -------------------------------章节分割线-------------------------------
\BiChapter{本次实验所评审的代码}{}


\noindent 姓名：张冠华~\\
学号：1150310323~\\
Github地址：https://github.com/miuws~\\

\noindent 姓名：王珊~\\
学号：1150310302~\\
Github地址：https://github.com/arthua196
\begin{figure}[h]
\begin{center}
  \includegraphics[width=\linewidth]{project.jpg}
  项目清单
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
  \includegraphics[width=\linewidth]{src.jpg}
  源码清单
\end{center}
\end{figure}


% -------------------------------章节分割线-------------------------------
\BiChapter{代码review记录}{}
\noindent
\begin{tabular}{|c|c|c|c|}
\hline
 问题描述 & 类型 & 所在代码行号 &  修改方式\\
\hline
\makecell[l] {在点击退出按钮后 \\ GUI界面关闭 \\ 但程序仍在运行} & 
\makecell[l] {程序退出控制}  & 
\makecell[l] {MainPage.java \\ : 467} &
\makecell[l] {增加代码 \\ setDefaultCloseOperation \\ (WindowConstants. \\ EXIT\_ON\_CLOSE) }\\ 

\hline

\end{tabular}



% -------------------------------章节分割线-------------------------------
\BiChapter{Checkstyle所发现的代码问题清单及原因分析}{}
\noindent
(使用 Sun Checks 规则)
~\\

\begin{adjustwidth}{-1pt}{}
\begin{tabular}{|c|c|c|c|c|}
\hline
编号 & 问题描述 & 类型 & 所在代码行号 & 修改策略 \\
\hline
1 &
\makecell[l] {类缺少JavaDoc} &
\makecell[l] {文档缺失} &
\makecell[l] {Edge.java \\ :3} &
\makecell[l] {补充Edge类文档} \\

\hline
2 &
\makecell[l] {大括号应位于 \\ 类、方法定义同一行} &
\makecell[l] {类、方法 \\ 定义格式} &
\makecell[l] {Edge.java \\ :4} &
\makecell[l] {将大括号放在 \\ 类、方法定义同一行} \\

\hline
3 &
\makecell[l] {','前缺少空格} &
\makecell[l] {空格格式} &
\makecell[l] {Edge.java \\ :5} &
\makecell[l] {补充空格} \\

\hline
4 &
\makecell[l] {应避免在 \\ 字表达式中赋值} &
\makecell[l] {赋值格式} &
\makecell[l] {Edge.java \\ :10} &
\makecell[l] {将赋值拆分成多行} \\

\hline
5 &
\makecell[l] {参数xxx应 \\ 定义为final的} &
\makecell[l] {只读参数、变量 \\ 用法} &
\makecell[l] {Edge.java \\ :12} &
\makecell[l] {为变量声明 \\ 增加final关键字} \\

\hline
6 &
\makecell[l] {'\{'后应换行} &
\makecell[l] {避免使用一行 \\ 定义方法} &
\makecell[l] {Edge.java \\ :33} &
\makecell[l] {为方法定义 \\ 规范换行} \\

\hline
7 &
\makecell[l] {if/else结构 \\ 必须使用大括号} &
\makecell[l] {控制结构 \\ 可读性} &
\makecell[l] {Edge.java \\ :36} &
\makecell[l] {为if结构 \\ 添加大括号} \\

\hline
8 &
\makecell[l] {数组大括号 \\ 位置错误} &
\makecell[l] {数组定义规范} &
\makecell[l] {Graph.java \\ :121} &
\makecell[l] {数组中括号 \\ 移至变量类型后} \\

\hline
9 &
\makecell[l] {xxx是一个 \\ 魔术数字} &
\makecell[l] {直接常数} &
\makecell[l] {Graph.java \\ :135} &
\makecell[l] {将数字赋值给常量} \\

\hline
10 &
\makecell[l] {不应以.*形式导入xxx} &
\makecell[l] {import规范} &
\makecell[l] {MainPage.java \\ :1} &
\makecell[l] {导入具体类名} \\

\hline
11 &
\makecell[l] {xxx应为private \\ 并配置访问方法} &
\makecell[l] {访问权限规范} &
\makecell[l] {MainPage.java \\ :13} &
\makecell[l] {访问权限改为private \\ 添加访问方法} \\

\hline
12 &
\makecell[l] {名称必须匹配 \\ 表达式xxx} &
\makecell[l] {命名规范} &
\makecell[l] {MainPage.java \\ :22} &
\makecell[l] {refactor修改命名} \\

\hline
13 &
\makecell[l] {本行字符数xxx \\ 最多xxx} &
\makecell[l] {行长度规范} &
\makecell[l] {MainPage.java \\ :80} &
\makecell[l] {拆成多行} \\
\hline

\end{tabular}
\end{adjustwidth}
~\\
(使用 Google 规则集的不同之处)
~\\
\begin{adjustwidth}{-1pt}{}
\begin{tabular}{|c|c|c|c|c|}
\hline
编号 & 问题描述 & 类型 & 所在代码行号 & 修改策略 \\
\hline
1 &
\makecell[l] {缩进空格应为两个} &
\makecell[l] {缩进格式} &
\makecell[l] {TextMaker.java \\ :13} &
\makecell[l] {(和规则集有关，不修改)} \\

\hline
2 &
\makecell[l] {包名导入顺序错误} &
\makecell[l] {import顺序错误} &
\makecell[l] {MainPage.java \\ :3} &
\makecell[l] {更改包导入顺序} \\

\hline
3 &
\makecell[l] {注释中的空行 \\  应该在<p>标签后} &
\makecell[l] {缩进格式} &
\makecell[l] {Graph.java \\ :35} &
\makecell[l] {(和规则集有关，不修改)} \\

\hline
4 &
\makecell[l] {其它if,for等 \\ 缩进空格数} &
\makecell[l] {缩进格式} &
\makecell[l] {Graph.java \\ :35} &
\makecell[l] {(和规则集有关，不修改)} \\
\hline
\end{tabular}
\end{adjustwidth}

~\\~\\
\noindent 小结：~\\
Sun和Google规则集大致相同。它们主要对这些问题进行检查：~\\
1、缩进~\\
2、有利于可读性的空格~\\
3、代码块是否正确地被大括号包围~\\

\noindent 不同的之处有：~\\
1、Google对缩进的要求是Sun规则集的一般~\\
2、Google规则集对JavaDoc的格式检查更严格~\\
3、Google规则集检查包名的导入顺序~\\
4、Sun规则集会检查部分内部逻辑


% -------------------------------章节分割线-------------------------------
\BiChapter{PMD所发现的代码问题清单及原因分析}{}
\noindent
优先级按照 https://pmd.github.io/pmd-5.8.1/pmd-java/rules/java 文档定义
~\\
\begin{adjustwidth}{-2em}{}
\begin{tabular}{|c|c|c|c|c|}
\hline
优先级 & 问题描述 & 违反的规则集合 & 代码行号 & 修改策略 \\
\hline
3 & 
\makecell[l] {变量、参数名过短 \\ 不易于理解} & 
\makecell[l] {naming} &
\makecell[l] {Edge.java \\ : 5} &
\makecell[l] {使用refactor \\ 更改命名} \\

\hline
3 & 
\makecell[l] {缺少包定义} & 
\makecell[l] {naming} &
\makecell[l] {Edge.java \\ : 3} &
\makecell[l] {为类编写文档} \\

\hline
4 & 
\makecell[l] {布尔型返回值 \\ 方法命名错误} & 
\makecell[l] {naming} &
\makecell[l] {Edge.java \\ : 33} &
\makecell[l] {用is、has、can等 \\ 命名此类方法} \\

\hline
3 & 
\makecell[l] {没有'\{'的if语句} & 
\makecell[l] {braces} &
\makecell[l] {Edge.java \\ : 46} &
\makecell[l] {为if结构增加'\{'} \\

\hline
3 & 
\makecell[l] {类中方法过多} & 
\makecell[l] {codesize} &
\makecell[l] {TextMaker.java \\ : 10} &
\makecell[l] {方法过多的类 \\ 应该重构} \\

\hline
3 & 
\makecell[l] {控制流程语句 \\ 过于复杂} & 
\makecell[l] {codesize} &
\makecell[l] {MainPage.java \\ : 69} &
\makecell[l] {重构以较少控制分支} \\

\hline
2 & 
\makecell[l] {缺少注释} & 
\makecell[l] {comments} &
\makecell[l] {Edge.java \\ : 3} &
\makecell[l] {添加注释} \\

\hline
3 & 
\makecell[l] {多个return的方法} & 
\makecell[l] {controversial} &
\makecell[l] {Edge.java \\ : 46} &
\makecell[l] {将返回值复制给变量 \\ 使用一个return返回} \\

\hline
3 & 
\makecell[l] {硬编码字面量} & 
\makecell[l] {controversial} &
\makecell[l] {Edge.java \\ : 46} &
\makecell[l] {赋予有意义的常量名} \\

\hline
3 & 
\makecell[l] {发现final局部变量} & 
\makecell[l] {controversial} &
\makecell[l] {Graph.java \\ : 51} &
\makecell[l] {将final局部变量 \\ 写成类的域} \\

\hline
3 & 
\makecell[l] {在操作数中赋值} & 
\makecell[l] {controversial} &
\makecell[l] {Graphviz.java \\ : 317} &
\makecell[l] {拆成多行，单独赋值} \\

\hline
3 & 
\makecell[l] {应显式指定访问权限} & 
\makecell[l] {controversial} &
\makecell[l] {MianPage.java \\ : 13} &
\makecell[l] {显示指定访问权限} \\

\hline
3 & 
\makecell[l] {使用具体实现的类 \\ 限制了功能的实现} & 
\makecell[l] {coupling} &
\makecell[l] {Graph.java \\ : 13} &
\makecell[l] {使用接口名 \\ 定义对象引用} \\
\hline
\end{tabular}
\end{adjustwidth}

~\\

\begin{adjustwidth}{-2em}{}
\begin{tabular}{|c|c|c|c|c|}
\hline
优先级 & 问题描述 & 违反的规则集合 & 代码行号 & 修改策略 \\
\hline
3 & 
\makecell[l] {只在初始化时复制的 \\ 变量应声明为final} & 
\makecell[l] {design} &
\makecell[l] {Edge.java \\ : 4} &
\makecell[l] {在域中初始化 \\ 并声明为final} \\

\hline
3 & 
\makecell[l] {使用了size=0 \\ 判断集合是否为空} & 
\makecell[l] {design} &
\makecell[l] {Graph.java \\ : 155} &
\makecell[l] {使用isEmpty方法替代} \\

\hline
3 & 
\makecell[l] {发现God Class \\ (过于复杂的类)} & 
\makecell[l] {design} &
\makecell[l] {Graph.java \\ : 1} &
\makecell[l] {重构类} \\

\hline
3 & 
\makecell[l] {使用了'=' \\ 比较对象} & 
\makecell[l] {design} &
\makecell[l] {MainPage.java \\ : 74} &
\makecell[l] {替换为equals方法} \\

\hline
2 & 
\makecell[l] {发现空的catch代码块} & 
\makecell[l] {empty} &
\makecell[l] {TextMaker \\ : 136} &
\makecell[l] {抛出RuntimeException \\ 或处理异常} \\

\hline
3 & 
\makecell[l] {发现调用System.Exit} & 
\makecell[l] {j2ee} &
\makecell[l] {MainPage.java \\ : 216} &
\makecell[l] {抛出异常} \\

\hline
3 & 
\makecell[l] {发现可以声明 \\ 为final的参数} & 
\makecell[l] {optimizations} &
\makecell[l] {Edge.java \\ : 14} &
\makecell[l] {未在方法中修改的参数 \\ 声明为final} \\

\hline
3 & 
\makecell[l] {发现重复的字面量} & 
\makecell[l] {string} &
\makecell[l] {Graph.java \\ : 249} &
\makecell[l] {将字面量值赋予常量} \\

\hline
3 & 
\makecell[l] {发现未使用的参数} & 
\makecell[l] {unusedcode} &
\makecell[l] {Graph.java \\ : 85} &
\makecell[l] {删除参数} \\
\hline
\end{tabular}
\end{adjustwidth}

~\\
\noindent 小结：~\\
PMD的各个规则集都要它们自己的要检查的规则~\\
如naming规则集检查命名问题，design规则集检查代码的结构逻辑~\\
要根据规则集关于其规则的描述，决定是否应该使用规则集


% -------------------------------章节分割线-------------------------------
\BiChapter{FindBugs所发现的代码问清单及原因分析}{}

\begin{adjustwidth}{-1pt}{}
\begin{tabular}{|c|c|c|c|}
\hline
问题描述 & 类型 & 所在代码行号 & 修改策略 \\
\hline
\makecell[l] {不是所有的代码路径 \\ 都关闭了流} &
\makecell[l] {IO资源释放} &
\makecell[l] {Graphviz.java \\ : 315} &
\makecell[l] {try with resource \\ 管理资源} \\

\hline
\makecell[l] {try catch 语句 \\ catch未处理} &
\makecell[l] {异常处理} &
\makecell[l] {Graphviz.java \\ : 48} &
\makecell[l] {直接抛出异常或 \\ 在方法内处理异常} \\

\hline
\makecell[l] {使用$\backslash$ n作为换行符} &
\makecell[l] {格式化符号 \\ 符合平台特性} &
\makecell[l] {Graph.java \\ : 249} &
\makecell[l] {将$\backslash$ n替换为\%n} \\

\hline
\makecell[l] {发现调用 \\ System.exit} &
\makecell[l] {System.exit \\ 用法错误} &
\makecell[l] {Graph.java \\ : 216} &
\makecell[l] {抛出 \\ RuntimeException} \\

\hline
\makecell[l] {BufferedWriter  \\ 未指定编码} &
\makecell[l] {对默认编码依赖} &
\makecell[l] {Graphviz.java \\ : 254} &
\makecell[l] {针对平台 \\ 指定编码参数} \\

\hline
\makecell[l] {使用硬编码 \\ 引用绝对路径} &
\makecell[l] {使用硬编码} &
\makecell[l] {TextMaker.java \\ : 268} &
\makecell[l] {使用相对路径 \\ 并赋值给常量} \\
\hline

\end{tabular}
\end{adjustwidth}

% -------------------------------章节分割线-------------------------------
\BiChapter{VisualVM性能分析结果}{}
在本章中，将利用VisualVM工具对项目的执行时间以及内存占用情况进行分析，并根据分析得出的结果对项目代码进行改进。
最后将测试改进后的代码的执行时间以及内存占用情况，并与为改进之前的情况进行对比。

\BiSection{执行时间的统计结果与原因分析}{}
在本节中，将分别分析项目在生成与展示有向图，查询桥接词，根据桥接词生成新文本，计算两个单词之间的最短路径，以及随机游走这五个功能方面的耗时，并对耗时的原因进行分析。

需要说明的是，虽然在Lab1的原始要求中“读取并生成有向图”以及“展示有向图”为两个功能，但是在该项目中完成文件的读取以及有向图的生成后即自动展示了有向图，因此在此将原始要求中的两个功能需求合并为“读取并展示有向图”一个功能，并对这一个功能进行分析。

\BiSubsection{生成与展示有向图}{}
在生成与展示有向图的时间测试中，我们采用Lab1验收时的测试数据作为输入进行测试，耗时结果的统计见图\ref{fig:time-1}。

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/time-1}
\caption{生成与展示有向图耗时}
\label{fig:time-1}
\end{figure}

需要首先特别说明的是，MenuListener.actionPerformed()的耗时为用户选择所要读取的文件时的耗时，因此不算在程序的运行时间内。

在耗时图像中，GraphViz.get\_img\_stream()为调用外部程序GraphViz绘制图像，并从GraphViz读取其返回的图像的二进制串的函数，GraphViz.createDotGraph()为接受GraphViz源程序作为输入，并最终将生成的图片写入到文件中的函数，TextMaker.exhibitGraph()为生成程序中图的结构对应的GraphViz源程序，并最终将生成的图片写入到文件中的函数，MainPage.setTextBoard()为配置GUI左侧展示文本框的函数，MainPage.showDirectedGraph()为配置GUI中展示有向图部分的GUI元素的函数。

由此可见，除去用户操作的时间外，主要占用时间的函数为GraphViz.get\_img\_stream()，MainPage.setTextBoard()，以及MainPage.showDirectedGraph()这三个函数。由于GraphViz.get\_img\_stream()为与GraphViz进行交互的函数，在不修改GraphViz的前提下没有更多优化的余地，并且MainPage.setTextBoard()与MainPage.showDirectedGraph()为控制GUI元素的函数，因此在使用同一GUI框架的前提下也无法进行优化，因此在生成与展示有向图的功能中无法通过耗时分析来进行这部分功能的优化。

\BiSubsection{查询桥接词}{}
在查询桥接词的测试中，我们同样采用Lab1验收的测试数据作为输入，即进行查询：
\begin{enumerate}
  \item 不存在的词的情况：first, second
  \item 不存在桥接词的情况：time, by
  \item 存在一个桥接词的情况：important, trends
  \item 存在多个桥接词的情况：the, of
\end{enumerate}
耗时分析结果见图\ref{fig:time-2}。

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/time-2}
\caption{查询桥接词耗时分析}
\label{fig:time-2}
\end{figure}

在耗时图像中，GraphViz.get\_img\_stream()为调用外部程序GraphViz绘制图像，并从GraphViz读取其返回的图像的二进制串的函数，MainPage.showDirectedGraph()为配置GUI中展示有向图部分的GUI元素的函数，MainPage\$ButtonListener.actionPerformed()为处理按钮点击事件的函数，TextMaker.exhibitGraph()为生成程序中图的结构对应的GraphViz源程序，并最终将生成的图片写入到文件中的函数，GraphViz.createDotGraph()为接受GraphViz源程序作为输入，并最终将生成的图片写入到文件中的函数，GraphViz.getGraph()为接受GraphViz源程序作为输入，并将生成的图片的二进制返回的函数，TextMaker.getBridgeWords()为查询有向图中桥接词的函数。

由以上分析可见，在查询桥接词的过程之中，占用时间的主要是GraphViz.get\_img\_stream()，MainPage.showDirectedGraph()这两个函数。与生成并展示有向图时的情况相同，我们没法在不改变GUI框架以及GraphViz实现原理的情况下对这两个函数进行优化。

\BiSubsection{根据桥接词生成新文本}
在根据桥接词生成新文本的测试中，我们同样采用Lab1验收的测试数据作为输入，其输入的文本分别为“In the big time servitization becomes the of the world.”，以及“In the big time, servitization one of the important trends-of the IT world.”。测试得出的耗时图像见图\ref{fig:time-3}。

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/time-3}
\caption{根据桥接词生成新文本耗时分析}
\label{fig:time-3}
\end{figure}

在耗时图像中，GraphViz.get\_img\_stream()为调用外部程序GraphViz绘制图像，并从GraphViz读取其返回的图像的二进制串的函数，GraphViz.writeDotSourceToFile()为接受GraphViz源代码作为输入，将源代码写入GraphViz源文件中的函数，MainPage\$ButtonListener.actionPerformed()为处理按钮点击事件的函数，TextMaker.exhibitGraph()为生成程序中图的结构对应的GraphViz源程序，并最终将生成的图片写入到文件中的函数，GraphViz.createDotGraph()为接受GraphViz源程序作为输入，并最终将生成的图片写入到文件中的函数，GraphViz.getGraph()为接受GraphViz源程序作为输入，并将生成的图片的二进制返回的函数，TextMaker.getBridgeWords()为查询有向图中桥接词的函数，TextMaker.getNewTextFromBridge()为根据输入的文本的桥接词生成新文本的函数。

由以上分析可知，占用时间的主要为GraphViz.get\_img\_stream()，GraphViz.writeDotSourceToFile()这两个函数。与之前分析的情况类似，在不改变通过GraphViz来生成图像的前提下，无法进一步从耗时方面提高程序的性能。

\BiSubsection{计算两个单词之间的最短路径}{}
在计算两个单词之间的最短路径的测试中，我们同样采用Lab1验收的测试数据作为输入，即测试：
\begin{enumerate}
\item 有一条最短路径的情况：time, word
\item 两个单词不可达的情况：this, study
\item 有多条最短路径的情况：the, word
\item 输入一个单词查询单源最短路径的情况：in
\end{enumerate}
测试得出的耗时图像见图\ref{fig:time-4}。

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/time-4}
\caption{计算两个单词之间的最短路径耗时分析}
\label{fig:time-4}
\end{figure}

在耗时图像中，GraphViz.get\_img\_stream()为调用外部程序GraphViz绘制图像，并从GraphViz读取其返回的图像的二进制串的函数，MainPage.showInformation()为配置GUI中显示结果提示信息部分的GUI元素的函数，MainPage.showDirectedGraph()为配置GUI中展示有向图部分的GUI元素的函数，TextMaker.exhibitGraph()为生成程序中图的结构对应的GraphViz源程序，并最终将生成的图片写入到文件中的函数，GraphViz.createDotGraph()为接受GraphViz源程序作为输入，并最终将生成的图片写入到文件中的函数，GraphViz.getGraph()为接受GraphViz源程序作为输入，并将生成的图片的二进制返回的函数，MainPage\$ButtonListener.actionPerformed()为处理按钮点击事件的函数，TextMaker.findShortestPath()为查询单源最短路径的函数。

由以上分析可知，占用时间的主要是GraphViz.get\_img\_stream()，MainPage.showInformation()，MainPage.showDirectedGraph()这三个函数。与之前的情况相同，在不改变GUI框架以及使用GraphViz进行绘图的前提下无法从耗时方面对计算两个单词之间最短路劲的性能进行优化。

\BiSubsection{随机游走}{}
在随机游走的测试中不需要输入，其耗时图像见图\ref{fig:time-5}。

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/time-5}
\caption{随机游走耗时分析}
\label{fig:time-5}
\end{figure}

在耗时图像中，GraphViz.get\_img\_stream()为调用外部程序GraphViz绘制图像，并从GraphViz读取其返回的图像的二进制串的函数，MainPage.showDirectedGraph()为配置GUI中展示有向图部分的GUI元素的函数，MainPage.setTextBoard()为配置GUI左侧展示文本框的函数，TextMaker.exhibitGraph()为生成程序中图的结构对应的GraphViz源程序，并最终将生成的图片写入到文件中的函数，GraphViz.createDotGraph()为接受GraphViz源程序作为输入，并最终将生成的图片写入到文件中的函数，GraphViz.getGraph()为接受GraphViz源程序作为输入，并将生成的图片的二进制返回的函数，MainPage\$ButtonListener.actionPerformed()为处理按钮点击事件的函数，TextMaker.findShortestPath()为查询单源最短路径的函数，TextMaker.randomWalkOnce()为随机游走一次的函数。

由以上分析可知，占用时间的主要是GraphViz.get\_img\_stream()，MainPage.showDirectedGraph()，MainPage.setTextBoard()三个函数。与之前的情况相同，在不改变GUI框架以及使用GraphViz进行绘图的前提下无法从耗时方面对计算两个单词之间最短路劲的性能进行优化。

\BiSection{内存占用的统计结果与原因分析}{}
在本节中，将分别分析项目在生成与展示有向图，查询桥接词，根据桥接词生成新文本，计算两个单词之间的最短路径，以及随机游走这五个功能方面的内存占用情况，并对占用内存的原因进行分析。

\BiSubsection{生成与展示有向图}{}
在生成与展示有向图部分，我们将主要考查多次读取输入文件时，是否发生了内存泄漏的情况。
测试的方法为分别记录读取一次文本，十次文本，二十次文本，三十次文本时的堆的使用情况，并进行比较。其中，每次读取使用相同的文本文件（也即Lab1的测试文件），并在每次记录数据前执行垃圾回收操作。由于程序每次读取文本时实际上在更新其内的有向图，并把原始文本以及预处理后的文本累加输出到GUI相应的文本框中，因此若无内存泄漏，则可预计java.lang.String在堆中的占用增加，其他类的占用应基本保持不变。

第一，二，三，四次记录的数据分别见图\ref{fig:mm-1-1}，图\ref{fig:mm-1-2}，图\ref{fig:mm-1-3}，图\ref{fig:mm-1-4}。读取三十次文本时记录的数据与读取一次文本时记录的数据的差异比较见图\ref{fig:mm-1-5}。

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-1-1}
\caption{读取一次文本时堆情况}
\label{fig:mm-1-1}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-1-2}
\caption{读取十次文本时堆情况}
\label{fig:mm-1-2}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-1-3}
\caption{读取二十次文本时堆情况}
\label{fig:mm-1-3}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-1-4}
\caption{读取三十次文本时堆情况}
\label{fig:mm-1-4}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-1-5}
\caption{读取三十次文本与读取一次文本比较}
\label{fig:mm-1-5}
\end{figure}

由图\ref{fig:mm-1-1}，图\ref{fig:mm-1-2}，图\ref{fig:mm-1-3}，图\ref{fig:mm-1-4}可见，每次记录数据时主要占用堆空间的类为char[]以及java.lang.String，合起来每次记录数据时都占用了超过40\%的堆空间。另外，从图\ref{fig:mm-1-1}到图\ref{fig:mm-1-4}的变化中可以看出，每次记录数据时占用堆空间较多的类的实例数以及大小并没有发生较大的改变。由读取三十次文本与读取一次文本时堆的比较可见看出，char[]的实例数增加了5\%，java.lang.String的实例数增加了5\%，HashMap\$Node的实例数增加了0.3\%，即只有char[]以及java.lang.String两个类的占用发生了小幅度的提升，其他类的堆占用基本保持不变。这与无内存泄漏的预期结果相符合，因此可以推断此过程中未发生内存泄漏。

\BiSubsection{查询桥接词}{}
在查询桥接词的功能中，我们主要测试多次查询桥接词时是否会出现内存泄漏的情况。
测试方法为读入Lab1测试数据中“读取并生成有向图”部分的文件数据，然后在此有向图上进行一次，十次，二十次查询有多个桥接词的两个单词the，of之间的桥接词，由此分析是否在查询桥接词的过程中发生了内存泄漏。其中，每次记录堆的数据占用情况前都进行垃圾回收。
由于程序每次完成桥接词的查询之后通过弹出对话框的方式显示查询到的桥接词，关闭对话框后查询结果即消失，因此若无内存泄漏，则可预计所有类的堆占用情况皆不会发生较大的改变。

第一，二，三次记录的数据分别见图\ref{fig:mm-2-1}，图\ref{fig:mm-2-2}，图\ref{fig:mm-2-3}。查询二十次桥接词时记录的数据与查询一次桥接词时记录的数据的差异比较见图\ref{fig:mm-2-4}。

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-2-1}
\caption{查询一次桥接词时堆情况}
\label{fig:mm-2-1}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-2-2}
\caption{查询十次桥接词时堆情况}
\label{fig:mm-2-2}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-2-3}
\caption{查询二十次桥接词时堆情况}
\label{fig:mm-2-3}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-2-4}
\caption{查询一次与查询二十次堆比较}
\label{fig:mm-2-4}
\end{figure}

由图\ref{fig:mm-2-1}，图\ref{fig:mm-2-2}，图\ref{fig:mm-2-3}，每次记录数据时主要占用堆空间的类同样为char[]以及java.lang.String。同样的，从图\ref{fig:mm-2-1}到图\ref{fig:mm-2-3}的变化中可以看出，每次记录数据时占用堆空间较多的类的实例数以及大小并没有发生较大的改变。由查询二十次桥接词与查询一次桥接词时堆的比较可见看出，char[]的实例数增加了1\%，java.lang.String的实例数增加了1\%，HashMap\$Node的实例数增加了0.3\%，基本可视作没有发生变化，与无内存泄漏时的预期基本一致，因此可以推断出在查询桥接词时为发生内存泄漏。

\BiSubsection{根据桥接词生成新文本}{}
\BiSubsection{计算两个单词之间的最短路径}{}
\BiSubsection{随机游走}{}

\BiSection{代码改进之后的执行时间统计结果}{}
在不改变GUI框架以及使用GraphViz进行绘图的前提下无法从耗时方面对计算两个单词之间最短路劲的性能进行优化。

\BiSubsection{随机游走}{}
在随机游走的测试中不需要输入，其耗时图像见图\ref{fig:time-5}。

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/time-5}
\caption{随机游走耗时分析}
\label{fig:time-5}
\end{figure}

在耗时图像中，GraphViz.get\_img\_stream()为调用外部程序GraphViz绘制图像，并从GraphViz读取其返回的图像的二进制串的函数，MainPage.showDirectedGraph()为配置GUI中展示有向图部分的GUI元素的函数，MainPage.setTextBoard()为配置GUI左侧展示文本框的函数，TextMaker.exhibitGraph()为生成程序中图的结构对应的GraphViz源程序，并最终将生成的图片写入到文件中的函数，GraphViz.createDotGraph()为接受GraphViz源程序作为输入，并最终将生成的图片写入到文件中的函数，GraphViz.getGraph()为接受GraphViz源程序作为输入，并将生成的图片的二进制返回的函数，MainPage\$ButtonListener.actionPerformed()为处理按钮点击事件的函数，TextMaker.findShortestPath()为查询单源最短路径的函数，TextMaker.randomWalkOnce()为随机游走一次的函数。

由以上分析可知，占用时间的主要是GraphViz.get\_img\_stream()，MainPage.showDirectedGraph()，MainPage.setTextBoard()三个函数。与之前的情况相同，在不改变GUI框架以及使用GraphViz进行绘图的前提下无法从耗时方面对计算两个单词之间最短路劲的性能进行优化。

\BiSection{内存占用的统计结果与原因分析}{}
在本节中，将分别分析项目在生成与展示有向图，查询桥接词，根据桥接词生成新文本，计算两个单词之间的最短路径，以及随机游走这五个功能方面的内存占用情况，并对占用内存的原因进行分析。

\BiSubsection{生成与展示有向图}{}
在生成与展示有向图部分，我们将主要考查多次读取输入文件时，是否发生了内存泄漏的情况。
测试的方法为分别记录读取一次文本，十次文本，二十次文本，三十次文本时的堆的使用情况，并进行比较。其中，每次读取使用相同的文本文件（也即Lab1的测试文件），并在每次记录数据前执行垃圾回收操作。由于程序每次读取文本时实际上在更新其内的有向图，并把原始文本以及预处理后的文本累加输出到GUI相应的文本框中，因此若无内存泄漏，则可预计java.lang.String在堆中的占用增加，其他类的占用应基本保持不变。

第一，二，三，四次记录的数据分别见图\ref{fig:mm-1-1}，图\ref{fig:mm-1-2}，图\ref{fig:mm-1-3}，图\ref{fig:mm-1-4}。读取三十次文本时记录的数据与读取一次文本时记录的数据的差异比较见图\ref{fig:mm-1-5}。

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-1-1}
\caption{读取一次文本时堆情况}
\label{fig:mm-1-1}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-1-2}
\caption{读取十次文本时堆情况}
\label{fig:mm-1-2}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-1-3}
\caption{读取二十次文本时堆情况}
\label{fig:mm-1-3}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-1-4}
\caption{读取三十次文本时堆情况}
\label{fig:mm-1-4}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-1-5}
\caption{读取三十次文本与读取一次文本比较}
\label{fig:mm-1-5}
\end{figure}

由图\ref{fig:mm-1-1}，图\ref{fig:mm-1-2}，图\ref{fig:mm-1-3}，图\ref{fig:mm-1-4}可见，每次记录数据时主要占用堆空间的类为char[]以及java.lang.String，合起来每次记录数据时都占用了超过40\%的堆空间。另外，从图\ref{fig:mm-1-1}到图\ref{fig:mm-1-4}的变化中可以看出，每次记录数据时占用堆空间较多的类的实例数以及大小并没有发生较大的改变。由读取三十次文本与读取一次文本时堆的比较可见看出，char[]的实例数增加了5\%，java.lang.String的实例数增加了5\%，HashMap\$Node的实例数增加了0.3\%，即只有char[]以及java.lang.String两个类的占用发生了小幅度的提升，其他类的堆占用基本保持不变。这与无内存泄漏的预期结果相符合，因此可以推断此过程中未发生内存泄漏。

\BiSubsection{查询桥接词}{}
在查询桥接词的功能中，我们主要测试多次查询桥接词时是否会出现内存泄漏的情况。
测试方法为读入Lab1测试数据中“读取并生成有向图”部分的文件数据，然后在此有向图上进行一次，十次，二十次查询有多个桥接词的两个单词the，of之间的桥接词，由此分析是否在查询桥接词的过程中发生了内存泄漏。其中，每次记录堆的数据占用情况前都进行垃圾回收。
由于程序每次完成桥接词的查询之后通过弹出对话框的方式显示查询到的桥接词，关闭对话框后查询结果即消失，因此若无内存泄漏，则可预计所有类的堆占用情况皆不会发生较大的改变。

第一，二，三次记录的数据分别见图\ref{fig:mm-2-1}，图\ref{fig:mm-2-2}，图\ref{fig:mm-2-3}。查询二十次桥接词时记录的数据与查询一次桥接词时记录的数据的差异比较见图\ref{fig:mm-2-4}。

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-2-1}
\caption{查询一次桥接词时堆情况}
\label{fig:mm-2-1}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-2-2}
\caption{查询十次桥接词时堆情况}
\label{fig:mm-2-2}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-2-3}
\caption{查询二十次桥接词时堆情况}
\label{fig:mm-2-3}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-2-4}
\caption{查询一次与查询二十次堆比较}
\label{fig:mm-2-4}
\end{figure}

由图\ref{fig:mm-2-1}，图\ref{fig:mm-2-2}，图\ref{fig:mm-2-3}，每次记录数据时主要占用堆空间的类同样为char[]以及java.lang.String。同样的，从图\ref{fig:mm-2-1}到图\ref{fig:mm-2-3}的变化中可以看出，每次记录数据时占用堆空间较多的类的实例数以及大小并没有发生较大的改变。由查询二十次桥接词与查询一次桥接词时堆的比较可见看出，char[]的实例数增加了1\%，java.lang.String的实例数增加了1\%，HashMap\$Node的实例数增加了0.3\%，基本可视作没有发生变化，与无内存泄漏时的预期基本一致，因此可以推断出在查询桥接词时为发生内存泄漏。

\BiSubsection{根据桥接词生成新文本}{}
在根据桥接词生成新文本的功能中，我们主要测试多次根据桥接词生成新文本时是否会出现内存泄漏的情况。
测试方法为读入Lab1测试数据中“读取并生成有向图”部分的文件数据，然后在此有向图上进行一次，十次，二十次对同一句子（采用Lab1验收时的句子）来根据桥接词生成新文本，由此分析是否在由桥接词生成新文本的过程中发生了内存泄漏。其中，每次记录堆的数据占用情况前都进行垃圾回收。
由于程序每次完成由桥接词生成新文本之后通过弹出对话框的方式显示生成的文本，关闭对话框后查询结果即消失，因此若无内存泄漏，则可预计所有类的堆占用情况皆不会发生较大的改变。

第一，二，三次记录的数据分别见图\ref{fig:mm-3-1}，图\ref{fig:mm-3-2}，图\ref{fig:mm-3-3}。执行二十次由桥接词生成新文本与执行一次由桥接词生成新文本时记录的数据的差异比较见图\ref{fig:mm-2-4}。

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-3-1}
\caption{执行一次时堆情况}
\label{fig:mm-3-1}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-3-2}
\caption{执行十次时堆情况}
\label{fig:mm-3-2}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-3-3}
\caption{执行二十次时堆情况}
\label{fig:mm-3-3}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/mm-3-4}
\caption{执行一次与执行二十次堆比较}
\label{fig:mm-3-4}
\end{figure}

由图\ref{fig:mm-2-1}，图\ref{fig:mm-2-2}，图\ref{fig:mm-2-3}，每次记录数据时主要占用堆空间的类同样为char[]以及java.lang.String。同样的，从图\ref{fig:mm-2-1}到图\ref{fig:mm-2-3}的变化中可以看出，每次记录数据时占用堆空间较多的类的实例数以及大小并没有发生较大的改变。由查询二十次桥接词与查询一次桥接词时堆的比较可见看出，char[]的实例数增加了1\%，java.lang.String的实例数增加了1\%，HashMap\$Node的实例数增加了0.3\%，基本可视作没有发生变化，与无内存泄漏时的预期基本一致，因此可以推断出在查询桥接词时为发生内存泄漏。

\BiSubsection{计算两个单词之间的最短路径}{}
\BiSubsection{随机游走}{}

\BiSection{代码改进之后的执行时间统计结果}{}
由在使用VisualVM进行耗时分析的结果可知，在不改变GUI框架以及使用GraphViz进行绘图的前提下无法从耗时方面对程序的性能进行优化。因此无法根据VisualVM测试所得到的耗时结果对其进行完善，故本节略过。

\BiSection{代码改进之后的内存占用统计结果}{}

% -------------------------------章节分割线-------------------------------
\BiChapter{利用Git/GitHub进行协作的过程}{}
本章中将描述在本次实验的第一，第二部分中利用Git与GitHub进行协作的截图与相应描述。

\BiSection{第一部分}{}
首先，需要在GitHub上找到待评审代码，fork至本组GitHub仓库内并重命名为Lab4，完成后截图见图\ref{fig:gh-1-1}。

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/gh-1-1}
\caption{Fork代评审代码至本组仓库}
\label{fig:gh-1-1}
\end{figure}

然后，将fork得到的仓库Lab4 clone至本组的本地仓库Lab4，完成后截图见图\ref{fig:gh-1-2}。

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/gh-1-2}
\caption{将远程仓库clone到本地}
\label{fig:gh-1-2}
\end{figure}

完成clone之后，人工review和工具review之后将修改提交至本地仓库，完成后截图见图\ref{fig:gh-1-3}。

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/gh-1-3}
\caption{将修改提交至本地仓库}
\label{fig:gh-1-3}
\end{figure}

提交至本地仓库后，将所有修改历史push到GitHub上本组仓库Lab4，完成后截图见图\ref{fig:gh-1-4}。

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/gh-1-4}
\caption{将本地仓库内容push至远程仓库}
\label{fig:gh-1-4}
\end{figure}

Push至远程仓库后，在Github上将最新的提交Pull Request到原作者的Lab1仓库，完成后截图见图\ref{fig:gh-1-5}。

\begin{figure}
\centering
\includegraphics[width=12cm]{/../figures/gh-1-5}
\caption{提交Pull Request}
\label{fig:gh-1-5}
\end{figure}

由此，即完成了利用Git与GitHub进行协作的第一部分。

% -------------------------------章节分割线-------------------------------
\BiChapter{评述}{}
\BiSection{对代码规范方面的评述}{}
\BiSection{对代码性能方面的评述}{}

% -------------------------------章节分割线-------------------------------
\BiChapter{计划与实际进度}{}
在本节中将描述本次实验中各个环节的任务名称，计划时间长度，实际耗费时间，以及提前或延期的原因分析。
\begin{table}
\caption{计划与进度}\label{tab:plan}
\begin{tabularx}{\linewidth}{|X|c|c|X|}
\hline
任务名称 & 计划时间长度（分钟） & 实际耗费时间（分钟） & 提前或延期的原因分析\\
\hline
\endhead
在IntelliJ下配置工具 & 30 & 60 & 工具配置不熟悉\\
\hline
\end{tabularx}
\end{table}

% -------------------------------章节分割线-------------------------------
\BiChapter{小结}{}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
